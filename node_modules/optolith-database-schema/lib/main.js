import addFormats from "ajv-formats";
import Ajv2019 from "ajv/dist/2019.js";
import Ajv2020 from "ajv/dist/2020.js";
import { lstat, readdir, readFile } from "fs/promises";
import { join } from "path";
import YAML from "yaml";
import { jsonSchemaDir } from "../config/directories.js";
import { typeValidatorMap } from "./config.js";
const readdirRecursive = async (dirPath) => {
    const directoryEntries = await readdir(dirPath, { withFileTypes: true });
    const flattenedRecursivePaths = await Promise.all(directoryEntries.map(async (dirEntry) => {
        const absoluteEntryPath = join(dirPath, dirEntry.name);
        if (dirEntry.isDirectory()) {
            return await readdirRecursive(absoluteEntryPath);
        }
        else if (dirEntry.isFile()) {
            return [absoluteEntryPath];
        }
        else {
            return [];
        }
    }));
    return flattenedRecursivePaths.flat();
};
const registerAllJsonSchemaDocuments = async (validatorOptions) => {
    const readFileAsUtf8 = (path) => readFile(path, "utf-8");
    const readFilesAsUtf8 = (paths) => Promise.all(paths.map(readFileAsUtf8));
    const parseJson = (json) => JSON.parse(json);
    const schemes = (await readFilesAsUtf8(await readdirRecursive(jsonSchemaDir))).map(parseJson);
    const META_SCHEMA_ID_2020_12 = "https://json-schema.org/draft/2020-12/schema";
    const validator = schemes[0]?.$schema === META_SCHEMA_ID_2020_12
        ? new Ajv2020(validatorOptions)
        : new Ajv2019(validatorOptions);
    const registerSchemaInValidator = (jsonSchema) => { validator.addSchema(jsonSchema); };
    schemes.forEach(registerSchemaInValidator);
    return validator;
};
const collator = Intl.Collator(undefined, { numeric: true });
const readDataFileAssocsFromDirectory = async (dirPath) => {
    const filenames = await readdir(dirPath);
    filenames.sort(collator.compare);
    return await Promise.all(filenames.map(async (fileName) => {
        const filePath = join(dirPath, fileName);
        try {
            const fileContent = YAML.parse(await readFile(join(dirPath, fileName), "utf-8"));
            return [filePath, fileContent];
        }
        catch (error) {
            if (error instanceof Error) {
                error.message = `in "${filePath}":\n  ${error.message}`;
            }
            return [filePath, null];
        }
    }));
};
const validateAllFromType = async (validator, typeName, path) => {
    const isFile = (await lstat(path)).isFile();
    const typeValidator = typeValidatorMap[typeName];
    if (isFile) {
        return { [path]: typeValidator(validator, await readFile(path, "utf-8"), path) };
    }
    else {
        const dataFiles = await readDataFileAssocsFromDirectory(path);
        return Object.fromEntries(dataFiles.map(([filePath, fileContent]) => [filePath, typeValidator(validator, fileContent, filePath)]));
    }
};
const rawResultMapToResult = (rawResultMap) => Object.entries(rawResultMap).reduce((result, [typeName, typeResults]) => Object.entries(typeResults).reduce((outerResult, [filePath, fileResult]) => {
    if (outerResult.tag === "Ok" && fileResult.tag === "Ok") {
        return {
            tag: "Ok",
            value: {
                ...outerResult.value,
                [typeName]: [...(outerResult.value[typeName] ?? []), fileResult.value]
            }
        };
    }
    else if (outerResult.tag === "Ok" && fileResult.tag === "Error") {
        return {
            tag: "Error",
            errors: {
                [filePath]: fileResult.errors
            }
        };
    }
    else if (outerResult.tag === "Error" && fileResult.tag === "Error") {
        return {
            tag: "Error",
            errors: {
                ...outerResult.errors,
                [filePath]: fileResult.errors
            }
        };
    }
    else {
        return outerResult;
    }
}, result), ({
    tag: "Ok",
    value: {}
}));
export const validate = async (entityDirPaths, checkIntegrity) => {
    const validator = await registerAllJsonSchemaDocuments({});
    addFormats(validator);
    const rawResultMap = Object.fromEntries((await Promise.all(Object.entries(entityDirPaths)
        .map(async ([typeName, path]) => [
        typeName,
        await validateAllFromType(validator, typeName, path)
    ]))));
    return rawResultMapToResult(rawResultMap);
};
export const printErrors = (errorsByFile, printOptions = {}) => {
    const { verbose = false } = printOptions;
    return Object.entries(errorsByFile)
        .flatMap(([filePath, errors]) => {
        if (verbose) {
            return filterNullable([
                errors.fileNameError ? errorMessageBlock([filePath], errors.fileNameError.message) : undefined,
                ...errors.schemaErrors.map(error => {
                    const pathSegments = [filePath, ...error.instancePath.split("/").slice(1)];
                    return errorMessageBlock(pathSegments, error.message ?? "");
                })
            ]);
        }
        else {
            return filterNullable([
                errors.fileNameError ? errorMessageBlock([filePath], errors.fileNameError.message) : undefined,
                errors.schemaErrors.length > 0 ? errorMessageBlock([filePath], "does not match schema") : undefined
            ]);
        }
    })
        .join("\n\n");
};
const errorMessageBlock = (path, message) => [
    ...path.map((segment, i) => `${" ".repeat(i * 2)}in "${segment}":`),
    `${" ".repeat(path.length * 2)}${message}`
].join("\n");
const filterNullable = (arr) => arr.filter((x) => x != null);
